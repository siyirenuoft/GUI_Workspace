
class TimelineCanvas(FigureCanvas):

    def __init__(self, parent=None, width=8, height=2, dpi=100, color=(134/255, 150/255, 167/255), label="", app_reference=None):
        self.app_reference = app_reference  # Reference to Haptics_App
        self.fig = Figure(figsize=(width, height), dpi=dpi, facecolor=color)
        self.axes = self.fig.add_axes([0.1, 0.15, 0.8, 0.8])  # Use add_axes to create a single plot
        self.axes.set_facecolor(color)
        
        # Set spine color and customize appearance
        spine_color = to_rgba((240/255, 235/255, 229/255))
        self.axes.spines['bottom'].set_color(spine_color)
        self.axes.spines['top'].set_color(spine_color)
        self.axes.spines['right'].set_color(spine_color)
        self.axes.spines['left'].set_color(spine_color)
        self.axes.tick_params(axis='x', colors=spine_color, labelsize=8)
        self.axes.tick_params(axis='y', colors=spine_color, labelsize=8)
        self.axes.set_ylabel('Amplitude', fontsize=9.5, color=spine_color)
        self.set_custom_xlabel('Time (s)', fontsize=9.5, color=spine_color)
        
        super(TimelineCanvas, self).__init__(self.fig)
        self.setParent(parent)
        self.setStyleSheet(f"background-color: rgba({int(color[0]*255)}, {int(color[1]*255)}, {int(color[2]*255)}, 0);")
        self.setAcceptDrops(True)
        
        self.signals = []  # List to store each signal's data along with their parameters

        # Variables to track dragging
        self._dragging = False
        self._last_mouse_x = None

        # dragggg
        self.signal_duration = 0  # Store the signal duration

    # dragggg
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and self.signal_duration > 10:
            self._dragging = True
            self._last_mouse_x = event.position().x()
    # dragggg
    def mouseMoveEvent(self, event):
        if self._dragging and self.signal_duration > 10:
            dx = event.position().x() - self._last_mouse_x
            self._last_mouse_x = event.position().x()
            xmin, xmax = self.axes.get_xlim()
            delta_x = dx * (xmax - xmin) / self.fig.get_size_inches()[0] / self.fig.dpi
            # Limit dragging to the signal duration
            if xmin - delta_x >= 0 and xmax - delta_x <= self.signal_duration:
                self.axes.set_xlim(xmin - delta_x, xmax - delta_x)
                self.draw()
    # dragggg
    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self._dragging = False

    def check_overlap(self, new_start_time, new_stop_time):
        for signal in self.signals:
            if not (new_stop_time <= signal["start_time"] or new_start_time >= signal["stop_time"]):
                return True
        return False

    def handle_overlap(self, new_start_time, new_stop_time, signal_type, signal_data, parameters):
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Time Range Overlap")
        msg_box.setText(f"The time range overlaps with an existing signal.")
        msg_box.setInformativeText("Would you like to replace the overlapping region or reset the time range of the new signal?")

        replace_button = msg_box.addButton("Replace", QMessageBox.ButtonRole.YesRole)
        reset_button = msg_box.addButton("Reset", QMessageBox.ButtonRole.NoRole)

        msg_box.exec()

        if msg_box.clickedButton() == replace_button:
            self.replace_overlap(new_start_time, new_stop_time, signal_data, signal_type, parameters)
        else:
            # Adjust the previous signal to keep non-overlapping parts
            self.adjust_previous_signals(new_start_time, new_stop_time)

            # Prompt the user to set a new time range for the new signal
            start_time, stop_time = self.show_time_input_dialog(signal_type)
            if start_time is not None and stop_time is not None and stop_time > start_time:
                if self.check_overlap(start_time, stop_time):
                    self.handle_overlap(start_time, stop_time, signal_type, signal_data)
                else:
                    self.record_signal(signal_type, signal_data, start_time, stop_time, None)


    def replace_overlap(self, new_start_time, new_stop_time, new_signal_data, new_signal_type, new_signal_parameters):
        adjusted_signals = []

        for signal in self.signals:
            if signal["start_time"] < new_start_time < signal["stop_time"]:
                # Case: The new signal overlaps the end of this signal
                if new_stop_time < signal["stop_time"]:
                    # Trim the end of the original signal and keep the non-overlapping part
                    signal_part = {
                        "type": signal["type"],
                        "data": signal["data"][:int((new_start_time - signal["start_time"]) * 500)],
                        "start_time": signal["start_time"],
                        "stop_time": new_start_time,
                        "parameters": signal["parameters"]
                    }
                    adjusted_signals.append(signal_part)
                else:
                    # Remove the overlapping portion of the original signal
                    signal["stop_time"] = new_start_time
                    signal["data"] = signal["data"][:int((new_start_time - signal["start_time"]) * 500)]
                    adjusted_signals.append(signal)

            elif signal["start_time"] < new_stop_time < signal["stop_time"]:
                # Case: The new signal overlaps the start of this signal
                signal["start_time"] = new_stop_time
                signal["data"] = signal["data"][int((new_stop_time - signal["start_time"]) * 500):]
                adjusted_signals.append(signal)

            elif new_start_time <= signal["start_time"] and new_stop_time >= signal["stop_time"]:
                # Case: The new signal completely overlaps this signal, so the original signal is removed

                continue
            else:
                # No overlap, keep the signal as is
                adjusted_signals.append(signal)

        # Add the new signal as well
        adjusted_signals.append({
            "type": new_signal_type,
            "data": new_signal_data,
            "start_time": new_start_time,
            "stop_time": new_stop_time,
            "parameters": new_signal_parameters
        })

        print(adjusted_signals)

        self.signals = adjusted_signals
        self.plot_all_signals()  # Update the plot with the modified signals


    def adjust_previous_signals(self, new_start_time, new_stop_time):
        adjusted_signals = []
        for signal in self.signals:
            if signal["start_time"] < new_start_time < signal["stop_time"]:
                # Case: The new signal overlaps the end of this signal
                if new_stop_time < signal["stop_time"]:
                    # Trim the end of the original signal and keep the non-overlapping part
                    signal_part = {
                        "type": signal["type"],
                        "data": signal["data"][:int((new_start_time - signal["start_time"]) * 500)],
                        "start_time": signal["start_time"],
                        "stop_time": new_start_time,
                        "parameters": signal["parameters"]
                    }
                    adjusted_signals.append(signal_part)
                else:
                    # Remove the overlapping portion of the original signal
                    signal["stop_time"] = new_start_time
                    signal["data"] = signal["data"][:int((new_start_time - signal["start_time"]) * 500)]
                    adjusted_signals.append(signal)
            elif signal["start_time"] < new_stop_time < signal["stop_time"]:
                # Case: The new signal overlaps the start of this signal
                signal["start_time"] = new_stop_time
                signal["data"] = signal["data"][int((new_stop_time - signal["start_time"]) * 500):]
                adjusted_signals.append(signal)
            elif signal["start_time"] < new_start_time and signal["stop_time"] > new_stop_time:
                # Case: The new signal completely overlaps this signal
                signal_part1 = {
                    "type": signal["type"],
                    "data": signal["data"][:int((new_start_time - signal["start_time"]) * 500)],
                    "start_time": signal["start_time"],
                    "stop_time": new_start_time,
                    "parameters": signal["parameters"]
                }
                signal_part2 = {
                    "type": signal["type"],
                    "data": signal["data"][int((new_stop_time - signal["start_time"]) * 500):],
                    "start_time": new_stop_time,
                    "stop_time": signal["stop_time"],
                    "parameters": signal["parameters"]
                }
                adjusted_signals.extend([signal_part1, signal_part2])
            else:
                # No overlap, keep the signal as is
                adjusted_signals.append(signal)

        self.signals = adjusted_signals


    def set_custom_xlabel(self, xlabel, fontsize=9.5, color='black'):
        self.axes.set_xlabel('')  # Remove default xlabel
        self.axes.annotate(xlabel, xy=(1.01, -0.01), xycoords='axes fraction', fontsize=fontsize, color=color, ha='left', va='center')

    def dragEnterEvent(self, event):
        if event.mimeData().hasFormat('application/x-qabstractitemmodeldatalist'):
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event):
        # Get the dragged signal type
        item = event.source().selectedItems()[0]
        signal_type = item.text(0)

        # Determine if the signal is customized or imported
        if signal_type in self.app_reference.custom_signals or signal_type in self.app_reference.imported_signals:
            signal_data = self.get_signal_data(signal_type)
            if signal_data:
                start_time, stop_time = self.show_time_input_dialog(signal_type)
                if start_time is not None and stop_time is not None and stop_time > start_time:
                    if self.check_overlap(start_time, stop_time):
                        self.handle_overlap(start_time, stop_time, signal_type, signal_data, parameters)
                    else:
                        self.record_signal(signal_type, signal_data, start_time, stop_time, None)
        else:
            parameters = self.prompt_signal_parameters(signal_type)
            if parameters is not None:
                start_time, stop_time = self.show_time_input_dialog(signal_type)
                if start_time is not None and stop_time is not None and stop_time > start_time:
                    signal_data = self.generate_signal_data(signal_type, parameters)
                    if self.check_overlap(start_time, stop_time):
                        self.handle_overlap(start_time, stop_time, signal_type, signal_data, parameters)
                    else:
                        self.record_signal(signal_type, signal_data, start_time, stop_time, parameters)

        # After recording the new signal, update the plot
        if self.signals:
            self.plot_all_signals()

        self.app_reference.actuator_signals[self.app_reference.current_actuator] = self.signals
        self.app_reference.update_actuator_text()


    def prompt_signal_parameters(self, signal_type):
        # Define mappings between signal types and dialogs
        signal_dialog_map = {
            "Sine": OscillatorDialog,
            "Square": OscillatorDialog,
            "Saw": OscillatorDialog,
            "Triangle": OscillatorDialog,
            "Chirp": OscillatorDialog,
            "FM": OscillatorDialog,
            "PWM": OscillatorDialog,
            "Noise": OscillatorDialog,
            "Envelope": EnvelopeDialog,
            "Keyed Envelope": EnvelopeDialog,
            "ASR": EnvelopeDialog,
            "ADSR": EnvelopeDialog,
            "Exponential Decay": EnvelopeDialog,
            "PolyBezier": EnvelopeDialog,
            "Signal Envelope": EnvelopeDialog
        }
        
        # Get the dialog class based on signal type
        dialog_class = signal_dialog_map.get(signal_type)
        
        if dialog_class:
            # Try without parent if dialog is black in certain contexts
            dialog = dialog_class(signal_type)  # Removed 'self' as parent
            # Optional: Force update
            dialog.update()
            
            # Repaint the parent widget, if needed
            self.repaint()
            
            if dialog.exec() == QDialog.DialogCode.Accepted:
                config = dialog.get_config()
                # Add validation or logging here if needed
                if config:
                    return config
                else:
                    print(f"Invalid parameters for {signal_type}.")
        else:
            print(f"Unrecognized signal type: {signal_type}")
            
        return None  # Return None if dialog was canceled or invalid


    def record_signal(self, signal_type, signal_data, start_time, stop_time, parameters):
        # Record the signal data and its parameters into the signals list
        self.signals.append({
            "type": signal_type,
            "data": signal_data,
            "start_time": start_time,
            "stop_time": stop_time,
            "parameters": parameters
        })

    def plot_all_signals(self):
        if not self.signals:
            # If no signals recorded, render a default plot with 10 seconds of 0 amplitude
            default_duration = 10  # seconds
            t = np.linspace(0, default_duration, 500 * default_duration)
            signal_data = np.zeros_like(t)
            self.plot_signal_data(t, signal_data)
            return

        # Determine the max stop time across all recorded signals
        max_stop_time = max([signal["stop_time"] for signal in self.signals])

        # dragggg
        # Store the signal duration for use in dragging functionality
        self.signal_duration = max_stop_time

        # Initialize an empty array of zeros for the full duration
        total_samples = int(max_stop_time * 500)
        combined_signal = np.zeros(total_samples)

        # Fill in the combined signal with each recorded signal's data
        for signal in self.signals:
            start_sample = int(signal["start_time"] * 500)
            stop_sample = int(signal["stop_time"] * 500)
            signal_duration = stop_sample - start_sample
            # Adjust the signal_data to fit the required duration (stretch or truncate as needed)
            if len(signal["data"]) > 0:
                signal_data = np.tile(signal["data"], int(np.ceil(signal_duration / len(signal["data"]))))[:signal_duration]
            else:
                # Handle the case where signal["data"] is empty
                # You can either skip this signal or generate a default signal.
                print(f"Warning: signal data is empty for signal {signal['type']}.")
                signal_data = np.zeros(signal_duration)  # Fallback to an empty signal for this duration

            combined_signal[start_sample:stop_sample] = signal_data

        # Generate time array for the x-axis
        t = np.linspace(0, max_stop_time, total_samples)
        self.plot_signal_data(t, combined_signal)

    def plot_signal_data(self, t, signal_data):
        # Clear the current plot and plot the new signal
        self.axes.clear()
        
        # Set spine color and customize appearance
        spine_color = to_rgba((240/255, 235/255, 229/255))
        self.axes.spines['bottom'].set_color(spine_color)
        self.axes.spines['top'].set_color(spine_color)
        self.axes.spines['right'].set_color(spine_color)
        self.axes.spines['left'].set_color(spine_color)
        self.axes.tick_params(axis='x', colors=spine_color, labelsize=8)
        self.axes.tick_params(axis='y', colors=spine_color, labelsize=8)
        self.axes.set_ylabel('Amplitude', fontsize=9.5, color=spine_color)
        self.set_custom_xlabel('Time (s)', fontsize=9.5, color=spine_color)

        # Plot the signal data
        self.axes.plot(t, signal_data, color=spine_color)

        # Check if the signal is longer than 10 seconds
        if self.signal_duration > 10:
            self.axes.set_xlim(0, 10)  # Show only the first 10 seconds initially
            
            # Adjust arrow size and location using mutation_scale
            arrow_props = dict(facecolor='gray', edgecolor='none', alpha=0.6, mutation_scale=50)

            # Left arrow at the start of the plot
            self.axes.annotate('', xy=(0.035, 0.5), xytext=(-0.1, 0.5),
                            xycoords='axes fraction', textcoords='axes fraction',
                            arrowprops=dict(arrowstyle='-|>', **arrow_props))

            # Right arrow at the end of the plot
            self.axes.annotate('', xy=(0.965, 0.5), xytext=(1.1, 0.5),
                            xycoords='axes fraction', textcoords='axes fraction',
                            arrowprops=dict(arrowstyle='-|>', **arrow_props))

        # Draw the updated plot
        self.draw()


    def generate_signal_data(self, signal_type, parameters):
        # Generate the signal data based on the type and modified parameters
        
        if signal_type == "Sine":
            t = np.linspace(0, 1, 500)
            return np.sin(2 * np.pi * parameters["frequency"] * t).tolist()
        elif signal_type == "Square":
            t = np.linspace(0, 1, 500)
            return np.sign(np.sin(2 * np.pi * parameters["frequency"] * t)).tolist()
        elif signal_type == "Saw":
            t = np.linspace(0, 1, 500)
            return (2 * (t * parameters["frequency"] - np.floor(t * parameters["frequency"] + 0.5))).tolist()
        elif signal_type == "Triangle":
            t = np.linspace(0, 1, 500)
            return (2 * np.abs(2 * (t * parameters["frequency"] - np.floor(t * parameters["frequency"] + 0.5))) - 1).tolist()
        elif signal_type == "Chirp":
            t = np.linspace(0, 1, 500)
            return np.sin(2 * np.pi * (parameters["frequency"] * t + 0.5 * parameters["rate"] * t**2)).tolist()
        elif signal_type == "FM":
            t = np.linspace(0, 1, 500)
            return np.sin(2 * np.pi * (parameters["frequency"] * t + parameters["rate"] * np.sin(2 * np.pi * parameters["frequency"] * t))).tolist()
        elif signal_type == "PWM":
            t = np.linspace(0, 1, 500)
            return np.where(np.sin(2 * np.pi * parameters["frequency"] * t) >= 0, 1, -1).tolist()
        elif signal_type == "Noise":
            t = np.linspace(0, 1, 500)
            return np.random.normal(0, 1, len(t)).tolist()
        elif signal_type == "Envelope":
            duration = parameters["duration"]
            num_samples = int(duration * 500)
            t = np.linspace(0, duration, num_samples)
            return (parameters["amplitude"] * np.sin(2 * np.pi * 5 * t)).tolist()
        elif signal_type == "Keyed Envelope":
            duration = parameters["duration"]
            num_samples = int(duration * 500)
            t = np.linspace(0, duration, num_samples)
            return (parameters["amplitude"] * np.sin(2 * np.pi * 5 * t) * np.exp(-3 * t)).tolist()
        elif signal_type == "ASR":
            duration = parameters["duration"]
            num_samples = int(duration * 500)
            t = np.linspace(0, duration, num_samples)
            return np.piecewise(t, [t < 0.3 * duration, t >= 0.3 * duration],
                                [lambda t: parameters["amplitude"] * (t / (0.3 * duration)), parameters["amplitude"]]).tolist()
        elif signal_type == "ADSR":
            duration = parameters["duration"]
            num_samples = int(duration * 500)
            t = np.linspace(0, duration, num_samples)
            return np.piecewise(t, [t < 0.1 * duration, t < 0.2 * duration, t < 0.5 * duration, t < 0.7 * duration, t >= 0.7 * duration],
                                [lambda t: parameters["amplitude"] * (t / (0.1 * duration)),
                                lambda t: parameters["amplitude"] * (1 - 5 * (t - 0.1 * duration) / duration),
                                0.5 * parameters["amplitude"],
                                lambda t: 0.5 * parameters["amplitude"] - 0.25 * parameters["amplitude"] * (t - 0.5 * duration) / duration,
                                0.25 * parameters["amplitude"]]).tolist()
        elif signal_type == "Exponential Decay":
            duration = parameters["duration"]
            num_samples = int(duration * 500)
            t = np.linspace(0, duration, num_samples)
            return (parameters["amplitude"] * np.exp(-5 * t / parameters["duration"])).tolist()
        elif signal_type == "PolyBezier":
            duration = parameters["duration"]
            num_samples = int(duration * 500)
            t = np.linspace(0, duration, num_samples)
            return (parameters["amplitude"] * (t ** 3 - 3 * t ** 2 + 3 * t)).tolist()
        elif signal_type == "Signal Envelope":
            duration = parameters["duration"]
            num_samples = int(duration * 500)
            t = np.linspace(0, duration, num_samples)
            return (parameters["amplitude"] * np.abs(np.sin(2 * np.pi * 3 * t))).tolist()
        return np.zeros_like(t).tolist()

    def get_signal_data(self, signal_type):
        # Retrieve signal data based on signal_type
        if signal_type in self.app_reference.custom_signals:
            return self.app_reference.custom_signals[signal_type]["data"]
        elif signal_type in self.app_reference.imported_signals:
            return self.app_reference.imported_signals[signal_type]["data"]
        return None

    def show_time_input_dialog(self, signal_type):
        dialog = TimeInputDialog(signal_type)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            start_time = dialog.start_time_input.value()
            stop_time = dialog.stop_time_input.value()
            return start_time, stop_time
        return None, None
class TimeInputDialog(QDialog):
    def __init__(self, signal_type, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Input Time Range")

        layout = QVBoxLayout(self)
        
        signal_label = QLabel(f"Signal Type: {signal_type}")
        
        layout.addWidget(signal_label)
        
        form_layout = QFormLayout()
        
        self.start_time_input = QDoubleSpinBox()
        self.start_time_input.setRange(0, 1000)  # Adjust range as needed
        form_layout.addRow("Start Time (s):", self.start_time_input)
        
        self.stop_time_input = QDoubleSpinBox()
        self.stop_time_input.setRange(0, 1000)  # Adjust range as needed
        form_layout.addRow("Stop Time (s):", self.stop_time_input)
        
        layout.addLayout(form_layout)
        
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)